Порядок действий:
Устанавливаем пакет django

    -> pip install django

Обновляем pip

    -> python.exe -m pip install --upgrade pip

Смотрим версии 

    -> pip list

>>>
Package  Version
-------- -------
asgiref  3.8.1
Django   5.1.2
pip      24.2
sqlparse 0.5.1
tzdata   2024.2

Ознакомиться с командами Django
    
    -> django-admin
    >>>
    > Available subcommands:
    ...

Для создания проекта команда: 

    -> django-admin startproject sitewomen

Команда создаст проект под названием sitewomen. Как правило, наименование проекта соответствует доменному имени сайта.
Создается пакет конфигурации в папке sitewomen

Заходим в папку проекта

    -> cd sitewomen

Запускаем локальный сервер
    
    -> python manage.py runserver

Запуститься локальный тестовый сервер, который будет доступен по адресу 
http://127.0.0.1:8000/

Чтобы остановить сервер 

    CTR+C или CTRL+BREAK

При первом запуске сервера создается файл базы данных 

    db.sqlite3

Если необходимо изменить порт, то можно запустить его на другом порту: 

    -> python manage.py runserver 4000

------------------------------------------------------------------------------------------------------------------------
Принцип работы фреймворка:

Модель MTV: Models - Модели
            Templates - Шаблоны
            Views - Представления

                         | --->>> Представление1 (View1) | --->>> Модель (Model)
    Маршрутизация по url |                               |
                         | --->>> Представление2 (View2) | --->>> Шаблоны (Templates)

При запрос от пользователя, например, когда вводит в строке браузера адрес страницы. 
Django проверяет указанные маршруты, и при нахождении совпадения, открывает то или иное представление.
Маршрут соответствует какому либо шаблону
127.0.0.1:8000/
127.0.0.1:8000/category/1/
127.0.0.1:8000/women/madonna/

Представление может быть реализовано в виде функции либо в виде класса, которое отвечает на соответствующий запрос 
Ответом является html страница, которая возвращается обратно пользователю.

Страница отрисовыается по опредленному шаблону. 

Данные в шаблон подставляются так же представлением и берутся из модели, которая взаимодействует с базой данных.
По простому:
Если приходит запрос, то представление, которое связано с этим маршрутом, берет шаблон, подставляет в него данные из
банных и возвращает клиенту в виде html страницы.

------------------------------------------------------------------------------------------------------------------------

Следующим шагом будет создание приложения сайта. 
Так как в философии Django указано, что нужно для каждой функциональной части сайта, делать отдельное приложение.
Приложения необходимо реализовывать максимально независимыми друг от друга.

Создаем первое приложение, которое будет ядром нашего сайта

Создание нового приложения

    -> python manage.py startapp women

После создается под каталог women с файлами конфигурации и рабочими файлами

Регистрация приложения в файле sitewomen/settings
INSTALD_APPS = [], добавляем имя нашего приложения
Можно прописать просто имя 'women', и при обращении к этому приложению Джанго будет обращаться 
к классу WomenConfig из файла women/apps.py
Поэтому лучше явно указать путь к этому файлу:
    
    'women.apps.WomenConfig'

------------------------------------------------------------------------------------------------------------------------
Следующий шаг - создание обработчика главной страницы и её маршрутизация

В файле women/views.py пропишем первое представление.

Для этого объявим функцию, но входе, которой будет переменная request
    
    def index(request):

request - ссылка на класс HTTPRequest, которая содержит информацию о запросе (Сессии, куки и т.д.)
на выходе возвращает объект класса HTTPResponse с содеримым ответа
Этот класс нужно импортировать

Потом эту функцию нужно связать с соответстветсвующим адресом.
На глобальном уровне в файле sitewomen/urls.py прописываем путь к созданному файлу.
path('women/', index), Здесь 'women/' это часть адреся в конце, index функция представления в приложении women 
Далее импортируем функцию 
from women.views import index
Для того чтобы Django смог увидеть папку приложения women нужно установить рабочий каталог
Для этого на дириктори проекта sitewomen кликаем правой кнопкой мыши выбираем пункт контекстного меню
Mark Directory As и выбираем Source Root

    path('index/', include('women.urls'))

Пропишем ещё одну функцию представления и маршрут на неё

sitewomen/urls.py

    from women.views import index, categories

    urlpatterns = [
        path('admin/', admin.site.urls),
        path('women/', index),
        path('categories/', categories),
    ]

women/views.py

    ...

    def categories(request):
        return HttpResponse("Вторая страница")

для того чтобы попадать сразу на главную страницу нужно прописать маршрут так:

    path('', index),

Импортировать лучше весь файл vies.py а в маршрутах указывать функции в следующем формате:
views.index и т.д.

будет выглядет так.

    from women import views

    urlpatterns = [
        path('admin/', admin.site.urls),
        path('', views.index),
        path('categories/', views.categories),
    ]

Лучшей практикой будет разделять маршруты приложений, для этого:
Создаем в папке приложения women файл urls.py
Потом, в глобальном файле sitewomen/urls.py подключаем созданный файл через функцию include()
path('', include('women.urls'),
В файле women/urls.py прописываем то же самое, но только уже для каждой функции представления

будет выглядеть так: 
sitewomen/urls.py

    from django.contrib import admin
    from django.urls import path, include
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('', include('women.urls')),
    ]


women/urls.py

    from django.urls import path
    from women import views
    
    
    urlpatterns = [
        path('', views.index),
        path('categories/', views.categories),
    ]

Если в глобальном url прописать  path('women', include('women.urls')), то в адресе всех страниц приложения будет добавляться суффикс women

------------------------------------------------------------------------------------------------------------------------

Настройка запуска сервера через кнопку, а не через комнаду в терминале. Так же можно будет проводить DEeBAG стандартными средствами PyCharm
Для этого у кнопки запуска выбираем Edit Configuration
 Добавляем Python конфигурацию через плюсик
 Вводим название проекта
 Выбираем рабочую директорию E:\PycharmProjects\Balakirev_site\sitewomen
 Выбираем наше виртуальное окружение
 В поле Script выбираем файл mange.py проекта
 В поле параметров прописываем runserver
После чего нажимаем кнопку Apply
Теперь можно запускать через зеленый треугольник. И можно так же запустить DeBug выбрав поля для отслеживания процесса работы программы.

------------------------------------------------------------------------------------------------------------------------
Конвертеры значений в маршрутах к функциям представлений.
У нас есть страничка с категориями. Ссылка на нее имеет следующий вид
http://127.0.0.1:8000/cats/
Предположим, у нас несколько категорий которые необходимо открывать по числовым индексам, для этого ссылка должна выглядеть следующим образом:
http://127.0.0.1:8000/cats/1/
http://127.0.0.1:8000/cats/2/
http://127.0.0.1:8000/cats/3/
и т.д.
Для этого нужно.
Прописаываем в маршруте конвертор и переменная, которя будет содержать целое чслов запросе:
'<int:cat_id>'
Путь теперь будет выглядеть так:

    path('cats/<int:cat_id>/', views.categories),

Эту переменную, 'cat_id' необходимо указать в функции представления

В данном примере она будет принимать то значение, которое будем указывать в ссылке. Сейчас это делается в ручном режиме, для демонстрации наглядности. 
После чего данная переменная должна отображаться на главной странице.
В итоге функция будет иметь следующий вид:

    def categories(request, cat_id):
        return HttpResponse(f"<h1>Вторая страница</h1><p>{cat_id}</p>")

на входе добавили переменную, на выходе выводим её на странице через f строку в теге <p>
Как это работает:
-> при указании в адресе строки какого либо числового значения http://127.0.0.1:8000/cats/1/ 
-> Django находит соответствующий маршрут и сохраняет 1 в переменную cat_id, 
-> После чего передает эту переменную в функцию представления, и уже функция возвращает это значение на главной странице  
Данный конвертер работ только на целые числа. Для других значений должны быть другие конвертеры, например <float:...>
Информация о всех конвертерах в документации в разделе Path converter
https://docs.djangoproject.com/en/5.1/topics/http/urls/#registering-custom-path-converters

Для демонстрации добавим ещё одну функцию представления и маршрут
    
    women/urls.py

    path('cats/<int:cat_id>/', views.categories),
    path('cats/<slug:cat_slug>/', views.categories_by_slug),
    
    womne/views.py

    def categories_by_slug(request, cat_slug):
        return HttpResponse(f"<h1>Статьи по категориям</h1><p>Cat_SLUG: {cat_slug}</p>")

Теперь при вводе в суффиксе адреса числового значения выводится страница с ID
А при вводе текстового значения и даже с указанием цифр и знаков выводится Cat_SLUG

Но если поменять маршруты местами, то при вводе цифрового значения все равно будет отрабатываться SLUG, а второй маршрут не будет отработан никогда
Так как фильтр slug включает в себя более обширный знаков в том числе и цифровой, рассматривая эти значения как строки.

Для чего это нужно:
Можно в маршруте указывать заранее заготовленную функцию, которая к примеру будет возвращать id строки в базе данных, и тогда
будет открываться страница с конкретной записью.

Если конверторов не достаточно, то есть функция re_path(),  которая работает с регулярными выражениями.
Для этого нужно её импортировать
Первый параметр в ней будет регулряным выражением

    re_path(r"^archive/(?P<year>[0-9]{4})/", views.archive),

r"" - строка
archive - префикс
?P<year> - создали перерменную
[0-9] - переменная должна состоять из цифр от 0 до 9
{4} - только четыре цифры в переменной
views.archive - новая функция представления

в функции представления указываем то же самое, что и указывали в других. Так же на входе переменная year, которая передается на выход в HTTPResponse()

    def archive(request, year):
        return HttpResponse(f"<h1>Архив по годам</h1><p>ГОД: {year}</p>")

при вводе строки http://127.0.0.1:8000/archive/2026/ на странице выводится 

>>>ГОД: 2026

Из минусов неудобная читаемость кода при использовании регулярного выражения
Для более удобной читаемости можно создать свой конвертер, пример есть в официальной документации
Создаем в папке women файл converters.py
В нем класс конвертера (В данном примере взял с оф. док.)

    class FourDigitYearConverter:
        regex = "[0-9]{4}"
    
        def to_python(self, value):
            return int(value)
    
        def to_url(self, value):
            return "%04d" % value

regex = "[0-9]{4}" - Параметры значения регулярного выражения, из цифр от 0 до 9 с длинной в 4 цифры
to_python - преобрзаование фрагмента url  втребуемый тип данных, выдает целые значения
to_url - наоборот преобразовывает данные в требуемый url, целые значения преобразовываются в строку.

women/urls.py
    
    from django.urls import path, re_path, register_converter # импортируем модуль register_converter
    from . import views
    from . import converters # Импортируем все из файла converters.py
    
    # Регистрируем конвертер
    
    register_converter(converters.FourDigitYearConverter, 'year4') # Регистрируем конвертер, где: модуль(наш_конвертер, название конвертера)

    urlpatterns = [
        path('', views.index),
        path('cats/<int:cat_id>/', views.categories),
        path('cats/<slug:cat_slug>/', views.categories_by_slug),
        path('archive/<year4:year>/', views.archive),, # Теперь можно записать конвертер уже в привычной форме, указав его название и добавив переменную
    ]

В данном примере при GET запросе, в конструкцию маршрута попадает строковое значение, после чего , это строковое значение попадает в класс конвертера
и преобразуется с помощью метода to_pyton в числовое значение. Метод срабатывает так как, используются входящие данные, которые исходя из GET запроса
всегда представляют строковое значение. После этого преобразования уже числовое значение отправляется в функцию представления и на выходе мы получаем это значение.


Ключевые моменты:
1. В маршруте можно указывать конвертеры, которые конвертируют те или иные значения из GET запроса 
    в некоторые значения и сохраняют их в каки-либо переменные Значение зависит от того какой конвертер выбран.
        Синтаксис: /<название конвертера:переменная>/
    Эти значения может отправлять в функции представления, 
2. Так же есть встроенная функция re_path() вместо path(), которая может работать с регулярными выражениями в качестве кастомного конвертера.
    Из минусов, сложная читабельность кода. 
   Синтаксис: re_path(r"^archive/(?P<year>[0-9]{4})/", views.archive),
3. Еще есть вариант создания своего конвертера. Для этого добавляется файл converters.py и в нем прописывается класс с заданными методами преобразования значений. 
    В этом случае импортируется встроенный модуль register_converter, Регистрируется созданный класс и назначается его имя
   А в маршруте в этом случае указывается конвертер уже с понятным синтаксисом: /<название конвертера:переменная>/
    

------------------------------------------------------------------------------------------------------------------------

Дополнительные параметры в GET-Запросах

В функции представления есть параметр request, который через метод .GET можно вывести эти параметры
Для примера в функции представления добавил следующее

    print(request.GET)

в строке браузера ввел дополнительные параметры: 

    http://127.0.0.1:8000/cats/slag/?name=Gagarina&type=Pop

в итоге в консоли у меня распечатались дополнительные параметры из переменной request
    
    <QueryDict: {'name': ['Gagarina'], 'type': ['Pop']}>

что соответствует вот этому запросу: ?name=Gagarina&type=Pop


------------------------------------------------------------------------------------------------------------------------

Обработка исключений
При вводе несуществующего URL В режиме DEBUG=True отображается страница Django с зарегистрированными путями
Но можно переключить в DEBUG=False, то необходимо в ALLOWED_HOSTS = [] ввести доменную страничку и тогда будет выводится 
сообщение Page Not Found
    
    DEBUG=False
    ALLOWED_HOSTS = ['127.0.0.1']

Для того чтобы выводилась нужная нам страница необходимо сделать следующее:
в глобальном URLS нужно прописать специальный обработчик 

    from women.views import page_not_found    

    Переменная зарезервированная в Django. Если неправильно написать, работать не будет
    handler404 = page_not_found

Мы определили переменную в которую направляем функцию представления для обработки исключения 404
и эту функцию определим в файле views приложения women

    from django.http import HttpResponseNotFound

    def page_not_found(request, exception):
    """
    Функция представление для обработки исключения PageNotFoundError
    :return: Страницу с надписью "Страница не найдена" 
    """
    return HttpResponseNotFound('<h1>Страница не найдена</h1>')

Здесь можно сделать переход на Главную страницу.
Так же можно в любом месте программы в функциях-представлениях сгенерировать ошибку 404 и тогда мы попадем на обрботку этого исключения через указанный обработчик
Пример: 

    def archive(request, year):
        if year > 2023:
            raise Http404()
        
        return HttpResponse(f"<h1>Архив по годам</h1><p>ГОД: {year}</p>")

Теперь, если отправть GET-запрос в данную функицю представления с несоответствующим значением переменно year, то будет сгенерировано исключение 404 и автоматически
будет запущена её обработка, и нас снова перекинут на страницу "Страница не найдена"

    http://127.0.0.1:8000/archive/2024/
    Страница не найдена

    http://127.0.0.1:8000/archive/2023/
    Архив по годам
    ГОД: 2023

https://docs.djangoproject.com/en/5.1/ref/urls/
Здесь собраны обработчики подобных исключений. 400, 403, 404, 500

------------------------------------------------------------------------------------------------------------------------

Перенаправление (redirect)

код 301 - страница перемещена на другой постоянный url
код 302 - страница перемещена временно на другой url
для примера:

    def archive(request, year):
        if year > 2023:
            return redirect('/') # Адрес главной страницы, можно указать какой-то другой
    
        return HttpResponse(f"<h1>Архив по годам</h1><p>ГОД: {year}</p>")

return redirect('/') -  в этом случае будет перемещено с кодом 302 
чтобы перемещение было с кодом 301, то необходимо указать параметр permanent=True

    def archive(request, year):
        if year > 2023:
            return redirect('/', permanent=True) # Адрес главной страницы, можно указать какой-то другой
    
        return HttpResponse(f"<h1>Архив по годам</h1><p>ГОД: {year}</p>")

>>> [25/Oct/2024 22:21:07] "GET /archive/2026/ HTTP/1.1" 301 0

Так же можно в redirect отправлять сразу функцию представления на страницу, которой необходимо перейти.

    def archive(request, year):
        if year > 2023:
            return redirect(index) # Указана функция представления Главной страницы сайта
    
        return HttpResponse(f"<h1>Архив по годам</h1><p>ГОД: {year}</p>")